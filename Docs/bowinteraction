搭箭核心逻辑：手里持箭的时候，如果手和stringoverlapbox发生碰撞，则自动把箭搭在弓弦上，自动使用grabobject抓取弓弦。
问题：手没有碰撞组件，无法通过overlap事件探测碰撞，解决办法：
	1.每帧判断手是否在stringoverlapbox内部
	2.给手添加一个碰撞体
	你觉得哪种好些？你还有更多办法吗？
PC拉弓（startdraw）逻辑：
	无剩余箭时：无法拉弓，这一点在basePCplayer里已经实现
	当有剩余箭时：先生成一支箭让手抓住，然后把手移到stringoverlapbox的位置，此时触发自动搭箭，手自动抓住弓弦。接着再把手interp到目标拉弓位置。（不使用我们现有的手动设置handinstringarea的设计，而是统一vr和pc逻辑）
VR拉弓逻辑：
	VRhand可以通过拾取场景里的箭或者从背包里取得箭来持有箭。
	手必须在stringoverlapbox范围里才可以和弓弦交互
	若手不持有箭：可以抓取弓弦，弓弦也会跟随手的位置
	若手持有箭：箭自动搭在弓弦上，手自动抓取弓弦
弓逻辑：
	如果弓弦被拉，有两种可能：
		没有箭：仅凭抓弓弦的手的位置+offset确定弓弦被抓的位置。
		有箭：在更新弓弦被抓的位置基础之上，还要更新搭在弓弦上的箭的位置与朝向。（位置在弓弦被抓的位置，朝向bowfrontposition）
	如果弓弦被释放，有两种可能：
		没有箭：仅松开弓弦，弓弦返回默认位置（注意使用弹簧阻尼来每帧更新弓弦位置）
		有箭：发射箭，根据弓弦释放位置和默认位置之间的距离来计算发射速度，有上下限。
		
		
阻尼逻辑
struct FSpringState
{
    FVector CurrentPos = FVector::ZeroVector;
    FVector PreviousPos = FVector::ZeroVector;
    FVector Velocity   = FVector::ZeroVector;
};

FVector SpringDamperStep(
    FSpringState& State,
    const FVector& TargetPos,   // P
    float InterpSpeed,           // T
    float Damping,               // D
    float Stability,             // S
    float DeltaTime
)
{
    if (DeltaTime <= KINDA_SMALL_NUMBER)
    {
        return State.CurrentPos;
    }

    // 1. 计算速度
    State.Velocity = (State.CurrentPos - State.PreviousPos) / DeltaTime;

    // 2. 更新 Previous
    State.PreviousPos = State.CurrentPos;

    // 3. 弹簧插值（Blueprint 的 VInterpTo）
    FVector SmoothedPos = FMath::VInterpTo(
        State.CurrentPos,
        TargetPos,
        DeltaTime,
        InterpSpeed
    );

    // 4. 阻尼
    float DampingFactor = FMath::Clamp(
        1.f - Damping * DeltaTime * Stability,
        0.f,
        1.f
    );

    State.Velocity *= DampingFactor;

    // 5. 积分
    FVector NewPos = SmoothedPos + State.Velocity * DeltaTime;

    State.CurrentPos = NewPos;
    return NewPos;
}

